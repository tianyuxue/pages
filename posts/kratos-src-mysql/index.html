<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Kratos 源码分析 - MySQL部分 | ACoder</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="
本文的讨论基于Kratos v1.0.x版本

Kratos是bilibili开源的一套Go微服务框架，包含大量微服务相关框架及工具，本文主要从源码角度分析一下Kratos中与MySQL相关的代码，在分析的过程中，我会从Kratos提供的不同的功能点来结合自己的一些理解进行阐述（这篇文章没有复杂的原理，只有从工程角度的一些最佳实践)。">
<meta name=generator content="Hugo 0.92.0">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<link rel="shortcut icon" href=/images/code.png type=image/x-icon>
<meta property="og:title" content="Kratos 源码分析 - MySQL部分">
<meta property="og:description" content="
本文的讨论基于Kratos v1.0.x版本

Kratos是bilibili开源的一套Go微服务框架，包含大量微服务相关框架及工具，本文主要从源码角度分析一下Kratos中与MySQL相关的代码，在分析的过程中，我会从Kratos提供的不同的功能点来结合自己的一些理解进行阐述（这篇文章没有复杂的原理，只有从工程角度的一些最佳实践)。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://tianyuxue.github.io/posts/kratos-src-mysql/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-01-07T00:00:00+00:00">
<meta property="article:modified_time" content="2021-01-07T00:00:00+00:00">
<meta itemprop=name content="Kratos 源码分析 - MySQL部分">
<meta itemprop=description content="
本文的讨论基于Kratos v1.0.x版本

Kratos是bilibili开源的一套Go微服务框架，包含大量微服务相关框架及工具，本文主要从源码角度分析一下Kratos中与MySQL相关的代码，在分析的过程中，我会从Kratos提供的不同的功能点来结合自己的一些理解进行阐述（这篇文章没有复杂的原理，只有从工程角度的一些最佳实践)。"><meta itemprop=datePublished content="2021-01-07T00:00:00+00:00">
<meta itemprop=dateModified content="2021-01-07T00:00:00+00:00">
<meta itemprop=wordCount content="712">
<meta itemprop=keywords content="kratos,mysql,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Kratos 源码分析 - MySQL部分">
<meta name=twitter:description content="
本文的讨论基于Kratos v1.0.x版本

Kratos是bilibili开源的一套Go微服务框架，包含大量微服务相关框架及工具，本文主要从源码角度分析一下Kratos中与MySQL相关的代码，在分析的过程中，我会从Kratos提供的不同的功能点来结合自己的一些理解进行阐述（这篇文章没有复杂的原理，只有从工程角度的一些最佳实践)。">
</head>
<body class="ma0 avenir bg-near-white">
<header class="cover bg-top" style=background-image:url(https://tianyuxue.github.io/images/cropped-valais-3562988_1920-2.jpg)>
<div class="pb3-m pb6-l bg-black-10">
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
<img src=/images/cropped-code.png class="w100 mw5-ns" alt=ACoder>
</a>
<div class="flex-l items-center">
<ul class="pl0 mr3">
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/posts/ title="文章 page">
文章
</a>
</li>
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/about/ title="关于我 page">
关于我
</a>
</li>
</ul>
<div class=ananke-socials>
<a href=https://github.com/tianyuxue target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</span></a>
</div>
</div>
</div>
</nav>
<div class="tc-l pv6 ph3 ph4-ns">
<h1 class="f2 f1-l fw2 white-90 mb0 lh-title">Kratos 源码分析 - MySQL部分</h1>
</div>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Kratos 源码分析 - MySQL部分</h1>
<p class=tracked>
By <strong>
jitianyu
</strong>
</p>
<time class="f6 mv4 dib tracked" datetime=2021-01-07T00:00:00Z>January 7, 2021</time>
<span class="f6 mv4 dib tracked"> - 4 minutes read </span>
<span class="f6 mv4 dib tracked"> - 712 words </span>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><blockquote>
<p>本文的讨论基于Kratos v1.0.x版本</p>
</blockquote>
<p>Kratos是bilibili开源的一套Go微服务框架，包含大量微服务相关框架及工具，本文主要从源码角度分析一下Kratos中与MySQL相关的代码，在分析的过程中，我会从Kratos提供的不同的功能点来结合自己的一些理解进行阐述（这篇文章没有复杂的原理，只有从工程角度的一些最佳实践)。</p>
<h2 id=1-核心对象的封装>1 核心对象的封装</h2>
<p>Kratos的数据层代码主要是对Golang SDK的二次封装。在GolangSDK中，database/sql包提供了对SQL的支持，具体而言，这个包提供了如下的抽象：</p>
<ul>
<li><code>DB</code> 抽象表示数据库本身，也可以将其理解为数据库连接池</li>
<li><code>Conn</code> 抽象表示单独一个数据库连接</li>
<li><code>Tx</code> 抽象表示一次数据库事务操作</li>
<li><code>Stmt</code> 抽象表示一个Prepared Statement</li>
<li><code>Row/Rows</code> 抽象表示一次数据库交互后的结果</li>
</ul>
<p><code>database/sql</code>包提供的这些抽象接口是直观的，易用的，足够应付简单的应用场景。Kratos对上面这几个对象再次进行了封装，提供了实际开发中经常用到的如下功能：</p>
<ul>
<li>MySQL读写分离</li>
<li>链路追踪</li>
<li>统计信息</li>
<li>慢查询日志记录</li>
<li>融断保护</li>
</ul>
<p>下面我从代码的角度分析下Kratos是如何实现上述功能的。</p>
<h2 id=2-功能点的实现>2 功能点的实现</h2>
<h3 id=21-mysql读写分离>2.1 MySQL读写分离</h3>
<p>Kratos从DAO层的代码层面实现了对MySQL读写分离的支持，并未使用数据库中间件。首先看下Kratos需要用户提供的MySQL集群配置信息：</p>
<pre tabindex=0><code>pkg/database/sql/mysql.go
type Config struct {
    DSN          string          // write data source name.
    ReadDSN      \[\]string        // read data source name
    Active       int             // pool
    Idle         int             // pool
    IdleTimeout  time.Duration   // connect max life time.
    QueryTimeout time.Duration   // query sql timeout
    ExecTimeout  time.Duration   // execute sql timeout
    TranTimeout  time.Duration   // transaction sql timeout
    Breaker      \*breaker.Config // breaker
}
</code></pre><p>可以看出，<code>DSN</code>和<code>ReadDSN</code>分别存储了MySQL主节点地址和从节点地址，从节点地址有多个。Kratos会根据上述配置，生成如下的连接池对象：</p>
<pre tabindex=0><code>type DB struct {
write  \*conn   //主节点连接池，conn定义见下文
read   \[\]\*conn //从节点连接池
idx    int64   // 用于选取从节点的id
master \*DB      //MySQL的主节点
}
</code></pre><p>DB对象使用<code>master</code>字段冗余存储主节点的信息，用来支持一些特定业务场景下，必须查询主库的操作。<code>write/read</code>字段分别表示数据库具体连接池，从<code>conn</code>类型的定义可以看到，其内部封装了Golang SDK中的 <code>sql.DB</code>对象：</p>
<pre tabindex=0><code>// conn database connection
type conn struct {
    \*sql.DB  // 对Golang SDK连接池的封装，用来支持MySQL读写分离
    breaker breaker.Breaker
    conf    \*Config
    addr    string
}
</code></pre><p>这样通过把Golang SDK中的<code>sql.DB</code>嵌入到<code>conn</code>对象中，再把多个<code>conn</code>对象封装到<code>DB</code>对象中，就使Kratos的<code>DB</code>对象支持了对MySQL集群的多个实例的读写。下面是Kratos中查询从库的方法：</p>
<pre tabindex=0><code>// Query executes a query that returns rows, typically a SELECT. The args are
// for any placeholder parameters in the query.
func (db \*DB) Query(c context.Context, query string, args ...interface{}) (rows \*Rows, err error) {
        // 获取要读取哪一个从库
	idx := db.readIndex()
	for i := range db.read {
		// 依次尝试每一个从库, 只要一个成功了就返回
		if rows, err = db.read\[(idx+i)%len(db.read)\].query(c, query, args...); !ecode.EqualError(ecode.ServiceUnavailable, err) {
			return
		}
	}
	// 从库失败了的话就查询主库
	return db.write.query(c, query, args...)
}

...

// 简单的使用轮询策略选择要读取的从库
func (db \*DB) readIndex() int {
	if len(db.read) == 0 {
		return 0
	}
	v := atomic.AddInt64(&amp;db.idx, 1)
	return int(v) % len(db.read)
}
</code></pre><p>从<code>readIndex()</code>方法中可以看到，Kratos在查询从库时候使用了简单轮寻的方法，每次查询前使用cas方式将内部变量idx自增，然后通过取mod的方式确定要查询哪一个从库。<code>Query()</code>方法中循环尝试读取每一个从库，<strong>只有读取成功了一次后才返回</strong>，这样避免了个别从库故障导致的读取失败。</p>
<p>除了读操作之外，对于写入的操作，Kratos同样对Golang SDK中sql.DB的如下方法进行了封装：</p>
<pre tabindex=0><code>// 启动MySQL事务
func (db \*DB) Begin(c context.Context) (tx \*Tx, err error) {
	return db.write.begin(c)
}

// 执行无返回结果的SQL语句
func (db \*DB) Exec(c context.Context, query string, args ...interface{}) (res sql.Result, err error) {
	return db.write.exec(c, query, args...)
}

// 创建Prepared Statement，如果出错会返回错误信息
func (db \*DB) Prepare(query string) (\*Stmt, error) {
	return db.write.prepare(query)
}

// 创建Prepared Statement，如果出错会后台重试
func (db \*DB) Prepared(query string) (stmt \*Stmt) {
	return db.write.prepared(query)
}

</code></pre><p>通过上述几个方法的封装，Kratos直接使用主库的数据库连接池进行插入删除等操作。这样Kratos在DAO的代码层面实现对Golang原生<code>database/sql</code>包的封装。</p>
<p>再看一下prepare statement的创建, Kratos的提供了<code>Prepared()</code>方法，如果创建prepare statement错误，那么启动一个goroutine不断重试，直到创建成功了，就用cas方法把prepare statement存储在Kratos封装的<code>Stmt</code>对象中， 个人感觉这样不够优雅，不知道b站内部是怎么用这个方法的：</p>
<p>// Stmt prepared stmt.
type Stmt struct {
db *conn
tx bool
query string
stmt atomic.Value // 存储创建好的prepare statement
t trace.Trace
}</p>
<p>&mldr;</p>
<p>func (db *conn) prepare(query string) (*Stmt, error) {
defer slowLog(fmt.Sprintf(&ldquo;Prepare query(%s)&rdquo;, query), time.Now())
stmt, err := db.Prepare(query)
if err != nil {
err = errors.Wrapf(err, &ldquo;prepare %s&rdquo;, query)
return nil, err
}
st := &Stmt{query: query, db: db}
st.stmt.Store(stmt)
return st, nil
}</p>
<p>func (db *conn) prepared(query string) (stmt *Stmt) {
defer slowLog(fmt.Sprintf(&ldquo;Prepared query(%s)&rdquo;, query), time.Now())
stmt = &Stmt{query: query, db: db}
s, err := db.Prepare(query)
if err == nil {
stmt.stmt.Store(s)
return
}
// 如果执行创建prepare出错了，这里后台执行不断重试，直到成功为止
go func() {
for {
s, err := db.Prepare(query)
if err != nil {
time.Sleep(time.Second)
continue
}
stmt.stmt.Store(s)
return
}
}()
return
}</p>
<p>除了MySQL读写分离，Kratos对其他方法的封装主要是为了提供慢查询日志，trace日志，监控信息和熔断保护这四个功能。</p>
<h3 id=22-慢查询日志>2.2 慢查询日志</h3>
<p>Kratos在每个与数据库交互方法中记录了慢查询日志，结合关键字<code>defer</code>，其实现方法非常简单：</p>
<p>&mldr;
func (db *conn) Query(c context.Context) (tx *Tx, err error) {
// 获取当前时间，通过defer来确定结束时间
now := time.Now()
defer slowLog(&ldquo;Begin&rdquo;, now)</p>
<p>&mldr;</p>
<p>// 时间超过阈值，就打印一条警告记录
func slowLog(statement string, now time.Time) {
du := time.Since(now)
if du > _slowLogDuration {
log.Warn("%s slow log statement: %s time: %v", _family, statement, du)
}
}</p>
<p>与数据库交互的每个方法中，Kratos都加入了上述代码片段记录慢查询的警告日志。</p>
<h3 id=23-监控信息>2.3 监控信息</h3>
<p>在数据库链接层面，Kratos封装了prometheus客户端代码，提供了4个主要的监控信息：</p>
<ul>
<li>请求处理时长</li>
<li>错误请求数</li>
<li>数据库连接总数</li>
<li>当前数据库连接数</li>
</ul>
<p>具体的代码如下：</p>
<p>pkg/database/sql/metrics.go</p>
<p>package sql</p>
<p>import &ldquo;github.com/go-kratos/kratos/pkg/stat/metric&rdquo;</p>
<p>const namespace = &ldquo;mysql_client&rdquo;</p>
<p>var (
_metricReqDur = metric.NewHistogramVec(&metric.HistogramVecOpts{
Namespace: namespace,
Subsystem: &ldquo;requests&rdquo;,
Name: &ldquo;duration_ms&rdquo;,
Help: &ldquo;mysql client requests duration(ms).&rdquo;,
Labels: []string{&ldquo;name&rdquo;, &ldquo;addr&rdquo;, &ldquo;command&rdquo;},
Buckets: []float64{5, 10, 25, 50, 100, 250, 500, 1000, 2500},
})
_metricReqErr = metric.NewCounterVec(&metric.CounterVecOpts{
Namespace: namespace,
Subsystem: &ldquo;requests&rdquo;,
Name: &ldquo;error_total&rdquo;,
Help: &ldquo;mysql client requests error count.&rdquo;,
Labels: []string{&ldquo;name&rdquo;, &ldquo;addr&rdquo;, &ldquo;command&rdquo;, &ldquo;error&rdquo;},
})
_metricConnTotal = metric.NewCounterVec(&metric.CounterVecOpts{
Namespace: namespace,
Subsystem: &ldquo;connections&rdquo;,
Name: &ldquo;total&rdquo;,
Help: &ldquo;mysql client connections total count.&rdquo;,
Labels: []string{&ldquo;name&rdquo;, &ldquo;addr&rdquo;, &ldquo;state&rdquo;},
})
_metricConnCurrent = metric.NewGaugeVec(&metric.GaugeVecOpts{
Namespace: namespace,
Subsystem: &ldquo;connections&rdquo;,
Name: &ldquo;current&rdquo;,
Help: &ldquo;mysql client connections current.&rdquo;,
Labels: []string{&ldquo;name&rdquo;, &ldquo;addr&rdquo;, &ldquo;state&rdquo;},
})
)</p>
<p>Kratos已经把上面监控数据嵌入在封装好的数据库交互的方法中，例如数据库读写发生错误后会调用<code>_metricReqErr.Inc()</code>, 读写完成后会调用<code>_metricReqDur.Observe()</code>。</p>
<h3 id=24-断路器>2.4 断路器</h3>
<p>Kratos的DB对象内置了断路器，存储在DB对象的breaker字段中，断路器的接口很简单，主要提供了如下三个方法：</p>
<p>// Breaker 定义了断路器接口
type Breaker interface {
Allow() error
MarkSuccess()
MarkFailed()
}</p>
<p>&mldr;
//在连接发出请求前判断熔断器状态
if err = conn.breaker.Allow(); err != nil {
return
}</p>
<p>//连接执行成功或失败将结果告知breaker
if(respErr != nil){
conn.breaker.MarkFailed()
}else{
conn.breaker.MarkSuccess()
}</p>
<p>Kratos在与数据库交互前会检查断路器状态，执行完SQL语句后更新断路器状态，例如在exec()方法中：</p>
<p>func (db *conn) exec(c context.Context, query string, args &mldr;interface{}) (res sql.Result, err error) {
&mldr;
// 执行方法前确认断路器状态
if err = db.breaker.Allow(); err != nil {
_metricReqErr.Inc(db.addr, db.addr, &ldquo;exec&rdquo;, &ldquo;breaker&rdquo;)
return
}
_, c, cancel := db.conf.ExecTimeout.Shrink(c)
res, err = db.ExecContext(c, query, args&mldr;)
cancel()
// 方法执行完毕后更新断路器状态
db.onBreaker(&err)
_metricReqDur.Observe(int64(time.Since(now)/time.Millisecond), db.addr, db.addr, &ldquo;exec&rdquo;)
if err != nil {
err = errors.Wrapf(err, &ldquo;exec:%s, args:%+v&rdquo;, query, args)
}
return
}</p>
<h3 id=25-trace信息>2.5 trace信息</h3>
<p>Kratos通过context来传递trace信息，见如下代码：</p>
<p>if t, ok := trace.FromContext(c); ok {
t = t.Fork(_family, &ldquo;exec&rdquo;)
t.SetTag(trace.String(trace.TagAddress, db.addr), trace.String(trace.TagComment, query))
defer t.Finish(&err)
}</p>
<p>在从context获取了trace的记录单元后，同样使用了defer关键字记录了日志的终止信息。上述代码片段在每一个数据库交互方法中都存在，这样就实现了在读写数据库层面的trace信息记录。</p>
<h2 id=3-总结>3 总结</h2>
<p>本文从源码层面讨论了Kratos框架对读写MySQL提供的一些工程上的最佳实践。</p><div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
<div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
<p class="f5 b mb3">Tags</p>
<ul class=pa0>
<li class=list>
<a href=/tags/kratos class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">kratos</a>
</li>
<li class=list>
<a href=/tags/mysql class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">mysql</a>
</li>
</ul>
</div>
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://tianyuxue.github.io/>
&copy; ACoder 2022
</a>
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://beian.miit.gov.cn/ rel="external nofollow" target=_blank>京ICP备2021000699号</a>
</div>
</footer>
</body>
</html>
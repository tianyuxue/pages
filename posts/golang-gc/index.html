<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于Golang GC的一些分析 | ACoder</title><meta name=keywords content="gc,golang"><meta name=description content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
"><meta name=author content="jitianyu"><link rel=canonical href=https://tianyuxue.github.io/pages/posts/golang-gc/><meta name=google-site-verification content="G-0T00DX73T1"><link crossorigin=anonymous href=/pages/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=images/code.png as=image><script defer crossorigin=anonymous src=/pages/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tianyuxue.github.io/pages/images/code.png><link rel=icon type=image/png sizes=16x16 href=https://tianyuxue.github.io/pages/images/code.png><link rel=icon type=image/png sizes=32x32 href=https://tianyuxue.github.io/pages/images/code.png><link rel=apple-touch-icon href=https://tianyuxue.github.io/pages/images/code.png><link rel=mask-icon href=https://tianyuxue.github.io/pages/images/code.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-0T00DX73T1"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0T00DX73T1",{anonymize_ip:!1})}</script><meta property="og:title" content="关于Golang GC的一些分析"><meta property="og:description" content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
"><meta property="og:type" content="article"><meta property="og:url" content="https://tianyuxue.github.io/pages/posts/golang-gc/"><meta property="og:image" content="https://tianyuxue.github.io/pages/images/mountain.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-02T00:00:00+00:00"><meta property="og:site_name" content="ACoder"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tianyuxue.github.io/pages/images/mountain.jpg"><meta name=twitter:title content="关于Golang GC的一些分析"><meta name=twitter:description content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://tianyuxue.github.io/pages/posts/"},{"@type":"ListItem","position":3,"name":"关于Golang GC的一些分析","item":"https://tianyuxue.github.io/pages/posts/golang-gc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于Golang GC的一些分析","name":"关于Golang GC的一些分析","description":" 本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法\n本文的讨论基于golang 1.15.4版本\n","keywords":["gc","golang"],"articleBody":" 本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法\n本文的讨论基于golang 1.15.4版本\n1 Golang采用的GC方案 Golang采用了并发标记-清除的GC方法，非分代，没有内存整理和移动，这与JVM有很大的不同。对于整个GC过程，源码runtime/mgc.go中给出了较为详细的描述，这里再做一个简要的梳理。整个GC分为以下4个阶段：\n1.sweep termination\n这个阶段发生在真正GC之前，用来清除上次GC后未被回收的内存，通常这个阶段不会发生，只有在执行了force gc的时候才会触发这个阶段，比如手动调用runtime.GC()函数。\n2.mark\nmark阶段分为如下几步：\n将变量gcphase从_GCoff设置为 _GCmark、开启写屏障功能、启动GC Assists。这个阶段会STW(Stop The World)，用户代码会暂停，直到所有P启动写屏障功能为止(如果对P的概念不理解，可以查看另一篇文章了解golang调度的原理)。\n写屏障启动之后会结束STW状态，用户代码可以正常执行，调度器启动GC Goroutine执行真正的标记任务，GC Assists开始接管GC过程中的内存分配，在这个过程中：\n写屏障会将GC过程中修改过的对象标记为灰色，GC过程中新分配的对象则直接标记为黑色，写屏障的作用是为了维持三色不变性，保证三色标记GC算法正常工作（三色标记算法过程后文介绍）\nGC Assist用来调节GC过程中的内存分配速度，直观理解，就是GC过程中，用户Goroutine分配的内存越多，其分配速度越慢，甚至会被调度器执行抢占式调度。\nGC Goroutine 会扫描所有栈，按照三色标记算法给扫描到的变量标记颜色, 扫描栈的时候，会暂停对应的goroutine, 扫描完成后再恢复gorouine的执行。\n三色标记算法的原理如下：\n初始所有变量为白色\n首先将全局变量、被栈引用的堆内对象标记为灰色\n随机选择一个灰色的对象，将其标记为黑色\n接着扫描该对象的所有可达对象，将可达对象也标记为灰色 重复上述过程，直到没有灰色的对象为止\n这时候白色对象就是可以被回收的。可以看出在整个算法过程中，灰色表示待扫描的对象，黑色代表扫描完毕不可以回收的对象，白色代表可回收的对象，这个不变的特性就称为三色不变性。\n3.mark termination\n在GC Goroutine扫描完所有的栈之后进入mark termination阶段，这个阶段同样会STW(Stop The World), 设置gcphase变量为_GCmarktermination, 然后执行一些资源清理的工作：\n停止GC Goroutine 禁用GC Assists 4.sweep\n标记结束之后进入sweep阶段，设置gcphace为 _GCoff, 禁用写屏障, 在这之后会Start The World， 启动执行用户代码，这时候意味着并发标记已经结束了，剩下的就是内存回收的工作了。\n从这个阶段开始，新的内存分配请求会复用被标记为可回收的内存，这意味着内存的回收是惰性的，不是立刻回收。 基于cpu使用情况，调度器可能启动额外的goroutine来执行内存回收 当新分配的内存达到GOGC设定的值后，再次触发GC, 重复上述步骤。\nGOGC用于调整GC频率，GOGC的默认值是100, 意味着下一次GC的触发时机是： 新分配的内存 = 当前GC结束后的剩余内存 × 100%， 例如当前GC结束后剩余4MB内存，当堆内存达到8MB时候，会再次触发GC GC过程示意图\n整个GC的过程可以见上图。这里再罗嗦一下，Golang采用无内存复制/移动的GC算法，很大的原因是为了兼容谷歌内部的大量C和C++代码，如果GC导致了堆对象的地址变化，那么对于调用C和C++代码而言非常困难。而由于协程的使用，启动写屏障、调度器启动GC Goroutine等操作实际是不涉及内核线程的上下文切换的，因此STW速度很快，这也是并发标记清除算法名称的由来，因此我们看到了Golang这种跟JVM完全不同的内存回收方案。\n2 实践GC调优 程序代码的执行必然伴随着内存的分配、修改和释放，GC将程序员从手动内存管理的繁琐工作中解放了出来，很大程度上提高了开发效率。就像任何事情一样，GC也不是免费的，GC的代价就在于消耗了CPU来执行了业务无关代码，从而造成用户代码执行的延迟。从这一点看GC调优与优化内存使用是密切相关的，造成GC过度延迟的根本原因就在于不恰当的内存分配和使用。\nGC调优的目的很简单：节约堆内存，降低GC造成的CPU消耗，避免因为GC而导致用户代码执行延迟，尤其是在某些延迟敏感的特定场景。衡量GC损耗的关键指标有三个：GC过程中的cpu使用率，STW时间和STW频率，这三个指标通常是互相关联的，总体上来说，GC的调优就是需要尽量减少内存分配和释放，尽量复用已经分配的内存。\n下面通过一个例子来分析GC调优的一些方法，这个例子中首先创建了长度为1000的256位随机字符串数组，然后在每一个web请求中随机生成一个字符串，然后再到字符串数组中查找，这个过程是对查找用户缓存的一个简单模拟，具体代码功能可以参考注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \"io\" \"math/rand\" \"net/http\" // 用于启动pprof的web接口 _ \"net/http/pprof\" \"strings\" ) // ids 模拟含有1000个用户id的缓存 var ids = make([]string, 1000) func main() { // 初始化缓存 for i := 0; i != 1000; i++ { s := getRandString(256) ids = append(ids, s) } http.HandleFunc(\"/slowgc\", slowGC) http.ListenAndServe(\":8080\", nil) } // slowGC 模拟由于内存分配导致的GC func slowGC(w http.ResponseWriter, r *http.Request) { currentUser := getRandString(256) for _, id := range ids { // 这里调用了strings.ToLower函数，这个函数会导致字符串的复制 if strings.Contains(strings.ToLower(currentUser), strings.ToLower(id)) { // if strings.Contains(id, currentUser) { io.WriteString(w, \"hit\") } } io.WriteString(w, \"not found\") } const letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" // getRandString 生成指定位数的字符串 func getRandString(length int) string { rnd := make([]byte, length) for i := range rnd { rnd[i] = letters[rand.Intn(len(letters))] } s := string(rnd) return s } 2.1 分析GC问题的瓶颈 要观察GC信息主要有以下三种方式\n使用GODEBUG=gctrace=1参数启动程序观察GC日志 go tool pprof工具可以用来详细分析内存分配，找出程序哪里分配了不合理的内存造成了GC压力 go tool trace工具可以列出整个代码执行过程中的详细信息。 下面我们通过上述的例子，打开GODEBUG=gctrace=1来分析一下GC信息。首先我们执行如下命令启动程序：\n1 2 go build main.go GODEBUG=gctrace=1 ./main 接着使用ab工具对接口进行压力测试：\n1 2 3 # -c 表示同时发送100个请求 # -n 表示请求总量一共10000个 ab -c 100 -n 10000 http://localhost:8080/slowgc ab工具可以得到类似的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ab -c 100 -n 10000 http://localhost:8080/slowgc This is ApacheBench, Version 2.3 \u003c$Revision: 1843412 $\u003e Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost (be patient) Completed 1000 requests Completed 2000 requests Completed 3000 requests Completed 4000 requests Completed 5000 requests Completed 6000 requests Completed 7000 requests Completed 8000 requests Completed 9000 requests Completed 10000 requests Finished 10000 requests Server Software: Server Hostname: localhost Server Port: 8080 Document Path: /slowgc Document Length: 3009 bytes Concurrency Level: 100 Time taken for tests: 23.753 seconds Complete requests: 10000 Failed requests: 0 Total transferred: 31060000 bytes HTML transferred: 30090000 bytes Requests per second: 421.00 [#/sec] (mean) Time per request: 237.529 [ms] (mean) Time per request: 2.375 [ms] (mean, across all concurrent requests) Transfer rate: 1276.98 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.3 0 5 Processing: 6 237 136.6 210 1217 Waiting: 6 230 136.2 204 1217 Total: 6 237 136.6 210 1217 Percentage of the requests served within a certain time (ms) 50% 210 66% 263 75% 301 80% 331 90% 412 95% 489 98% 598 99% 704 100% 1217 (longest request) 可以看出上面代码的简单逻辑，每秒钟处理的请求数量只有421个，按道理来说简单的字符串查找不应该这么慢，那么问题出在哪里呢，接着看下刚才过程中的gctrace信息：\n... gc 2619 @25.802s 9%: 0.060+0.61+0.019 ms clock, 0.24+0.73/0.49/0+0.079 ms cpu, 4-\u003e4-\u003e1 MB, 5 MB goal, 4 P gc 2620 @25.810s 9%: 0.085+0.68+0.022 ms clock, 0.34+0.80/0.57/0+0.088 ms cpu, 4-\u003e4-\u003e0 MB, 5 MB goal, 4 P gc 2621 @25.818s 9%: 0.057+0.42+0.019 ms clock, 0.23+0.63/0.30/0+0.076 ms cpu, 4-\u003e4-\u003e0 MB, 5 MB goal, 4 P gc 2622 @25.826s 9%: 0.76+1.7+0.019 ms clock, 3.0+1.9/0.40/0+0.078 ms cpu, 4-\u003e4-\u003e1 MB, 5 MB goal, 4 P 观察压测结束后的gc日志，可以看出10000个请求一共触发了2622次GC，其中GC Groutine一共使用了将近百分之十的CPU，在这样一个简单的业务逻辑下，GC触发的频率明显过高，并且占用的CPU时间也过高（关于GC trace信息的阅读可以参考文末附录），这是不合理的，GC的行为不符合预期的时候，我们首先应该从内存是否合理分配来入手分析，接下来我们可以使用go tool pprof工具来查看一下上述代码的内存使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 go tool pprof http://localhost:8080/debug/pprof/allocs Fetching profile over HTTP from http://localhost:8080/debug/pprof/allocs Saved profile in /root/pprof/pprof.go-gc-tutorial.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz File: go-gc-tutorial Type: alloc_space Time: Jan 2, 2021 at 9:39pm (CST) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top 6 -cum Showing nodes accounting for 0, 0% of 7.26GB total Dropped 58 nodes (cum \u003c= 0.04GB) Showing top 6 nodes out of 8 flat flat% sum% cum cum% 0 0% 0% 7.25GB 99.91% net/http.(*conn).serve 0 0% 0% 7.16GB 98.68% main.slowGC 0 0% 0% 7.16GB 98.68% net/http.(*ServeMux).ServeHTTP 0 0% 0% 7.16GB 98.68% net/http.HandlerFunc.ServeHTTP 0 0% 0% 7.16GB 98.68% net/http.serverHandler.ServeHTTP 0 0% 0% 7.16GB 98.61% strings.(*Builder).Grow (inline) (pprof) (pprof) list slowGC Total: 7.26GB ROUTINE ======================== main.slowGC in /data/codes/go-gc/main1.go 0 7.16GB (flat, cum) 98.68% of Total . . 25:\thttp.ListenAndServe(\":8080\", nil) . . 26:} . . 27: . . 28:// slowGC 模拟由于内存分配导致的GC . . 29:func slowGC(w http.ResponseWriter, r *http.Request) { . 4.50MB 30:\tcurrentUser := getRandString(256) . . 31:\tfor _, id := range ids { . . 32:\t// 这里调用了strings.ToLower函数，这个函数会导致字符串的复制 . 7.16GB 33:\tif strings.Contains(strings.ToLower(currentUser), strings.ToLower(id)) { . . 34:\t// if strings.Contains(id, currentUser) { . 512.02kB 35:\tio.WriteString(w, \"hit\") . . 36:\t} . . 37:\t} . . 38:\tio.WriteString(w, \"not found\") . . 39:} . . 40: 首先使用命令\ngo tool pprof http://localhost:8080/debug/pprof/allocs 进入pprof工具的交互模式，然后输人top 5 -cum查看分配内存最多的5个函数，从输出结果我们可以看出，slowGC函数分配了7GB左右的内存，这有一些奇怪，然后我们可以执行list slowGC命令，可以看出在第33行调用的操作字符串的方法分配内存最多，至此原因大概明白了，golang中string类型是不可变的，每次调用strings.ToLower()方法时候都会申请内存分配一个新的字符串，最后就造成的每次循环中都会申请一块新内存，从而造成GC压力（调用ToLower()方法只是为了举例说明GC问题，并无实际的意义）。我们可以针对这个问题做一下简单的修改，将第33行的ToLower()函数移动到循环之外：\npackage main import ( \"io\" \"math/rand\" \"net/http\" // 用于启动pprof的web接口 _ \"net/http/pprof\" \"strings\" ) // ids 模拟含有1000个用户id的缓存 var ids = make([]string, 1000) func main() { // 初始化缓存 for i := 0; i != 1000; i++ { s := getRandString(256) s = strings.ToLower(s) ids = append(ids, s) } http.HandleFunc(\"/slowgc\", slowGC) http.ListenAndServe(\":8080\", nil) } // slowGC 模拟由于内存分配导致的GC func slowGC(w http.ResponseWriter, r *http.Request) { currentUser := getRandString(256) // 将ToLower()的调用移动到循环之外 currentUser = strings.ToLower(currentUser) for _, id := range ids { if strings.Contains(id, currentUser) { io.WriteString(w, \"hit\") } } io.WriteString(w, \"not found\") } const letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" // getRandString 生成指定位数的字符串 func getRandString(length int) string { rnd := make([]byte, length) for i := range rnd { rnd[i] = letters[rand.Intn(len(letters))] } s := string(rnd) return s } 再次执行上述压测命令，可以看到压测结果为：\nab -c 100 -n 10000 http://localhost:8080/slowgc This is ApacheBench, Version 2.3 \u003c$Revision: 1843412 $\u003e Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost (be patient) Completed 1000 requests Completed 2000 requests Completed 3000 requests Completed 4000 requests Completed 5000 requests Completed 6000 requests Completed 7000 requests Completed 8000 requests Completed 9000 requests Completed 10000 requests Finished 10000 requests Server Software: Server Hostname: localhost Server Port: 8080 Document Path: /slowgc Document Length: 9 bytes Concurrency Level: 100 Time taken for tests: 0.880 seconds Complete requests: 10000 Failed requests: 0 Total transferred: 1250000 bytes HTML transferred: 90000 bytes Requests per second: 11369.89 [#/sec] (mean) Time per request: 8.795 [ms] (mean) Time per request: 0.088 [ms] (mean, across all concurrent requests) Transfer rate: 1387.93 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 4 0.8 3 10 Processing: 1 5 1.8 5 19 Waiting: 1 4 1.6 4 17 Total: 4 9 1.8 8 23 WARNING: The median and mean for the initial connection time are not within a normal deviation These results are probably not that reliable. Percentage of the requests served within a certain time (ms) 50% 8 66% 9 75% 9 80% 10 90% 11 95% 12 98% 13 99% 16 100% 23 (longest request) 从ab命令执行结果来看，处理速度有了极大的改进，每秒处理的请求数量达到了11369，而查看gctrace日志，也可以看到整个过程中只触发了10几次GC：\n... gc 10 @5.149s 0%: 0.097+0.84+0.007 ms clock, 0.38+1.4/0.001/0+0.028 ms cpu, 4-\u003e4-\u003e1 MB, 5 MB goal, 4 P gc 11 @5.208s 0%: 0.037+0.79+0.004 ms clock, 0.14+0.65/0.56/0.25+0.016 ms cpu, 4-\u003e4-\u003e1 MB, 5 MB goal, 4 P gc 12 @5.277s 0%: 0.039+0.71+0.003 ms clock, 0.15+0.71/0.55/0+0.014 ms cpu, 4-\u003e4-\u003e1 MB, 5 MB goal, 4 P gc 13 @5.346s 0%: 0.023+1.0+0.013 ms clock, 0.094+0.78/0.66/0+0.055 ms cpu, 4-\u003e4-\u003e1 MB, 5 MB goal, 4 P 小结一下，这部分使用了gctrace日志和pprof工具发现了代码中内存分配的缺陷，通过修改代码解决了问题。\n2.2 调节GOGC参数 上述内存造成的问题也可通过调整GOGC参数来给予临时解决，为什么说是临时解决呢？因为通常修改GOGC参数，虽然减少了GC的触发频率，也可能会带来更长单次GC时间。要从根本上解决GC问题，还是要从代码，或者业务逻辑入手进行优化。下面我们再看下GOGC参数如何影响GC操作。我们用下面的命令设置GOGC的值为500， 意味着堆内存增长5倍，下一次GC才会触发，重新执行2.1中有问题的代码：\nGOGC=500 GODEBUG=gctrace=1 ./main 同样执行ab命令进行压测后，得到如下结果：\nab -c 100 -n 10000 http://localhost:8080/slowgc This is ApacheBench, Version 2.3 \u003c$Revision: 1843412 $\u003e Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost (be patient) Completed 1000 requests Completed 2000 requests Completed 3000 requests Completed 4000 requests Completed 5000 requests Completed 6000 requests Completed 7000 requests Completed 8000 requests Completed 9000 requests Completed 10000 requests Finished 10000 requests Server Software: Server Hostname: localhost Server Port: 8080 Document Path: /slowgc Document Length: 3009 bytes Concurrency Level: 100 Time taken for tests: 18.846 seconds Complete requests: 10000 Failed requests: 0 Total transferred: 31060000 bytes HTML transferred: 30090000 bytes Requests per second: 530.62 [#/sec] (mean) Time per request: 188.459 [ms] (mean) Time per request: 1.885 [ms] (mean, across all concurrent requests) Transfer rate: 1609.48 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.3 0 4 Processing: 6 187 136.9 173 1171 Waiting: 5 184 135.5 170 1171 Total: 6 187 136.9 173 1171 Percentage of the requests served within a certain time (ms) 50% 173 66% 226 75% 256 80% 283 90% 362 95% 437 98% 545 99% 641 100% 1171 (longest request) 从ab命令结果可以看出，每秒的请求较之前的400多次变为了500多次，性能略有提升，而gc日志也可以看出，由于修改了GC触发的频率，实际触发的GC次数为394次，比之前的2000多次也是明显减少，整个GC过程的CPU使用率也维持在1%。通过这个例子可以看出，根据实际情况调整GC触发频率对于GC效率是会有较大提升的，但是具体如何设置GOGC的值就是一个开放问题了，需要在不同的场景下不断的测试，最终得到符合当前场景的参数值。\n... gc 391 @21.304s 1%: 0.063+0.58+0.015 ms clock, 0.25+0.81/0.53/0+0.061 ms cpu, 20-\u003e20-\u003e1 MB, 21 MB goal, 4 P gc 392 @21.350s 1%: 0.071+0.38+0.017 ms clock, 0.28+0.76/0.32/0+0.069 ms cpu, 20-\u003e20-\u003e1 MB, 21 MB goal, 4 P gc 393 @21.395s 1%: 0.059+0.36+0.015 ms clock, 0.23+0.57/0.29/0+0.061 ms cpu, 20-\u003e20-\u003e0 MB, 21 MB goal, 4 P gc 394 @21.439s 1%: 0.066+0.41+0.018 ms clock, 0.26+0.50/0.36/0+0.075 ms cpu, 20-\u003e20-\u003e0 MB, 21 MB goal, 4 P 2.3 GC调优的其他方法 除了上述的GC调优方法之外，golang编译器提供了逃逸分析的方法，具体而言就是编译器如果可以判断出一个变量创建后只存活在当前栈帧中，那么在当前栈被销毁时候，变量也可以直接销毁，这样就不再需要执行GC去做这部分工作。实际中可以使用go build -gcflags=-m来打开逃逸分析的提示。\n除了逃逸分析之外，另一种常见的控制内存分配的方法是将常用的内存对象池化，sync.Pool就提供了池化对象的支持，除此之外，很多三方库也可以使用，比如https://github.com/valyala/bytebufferpool。\n3 总结 本文首先介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法。\n本有还有如下的不足：未对逃逸分析和池化对象给出具体的示例。\n4 参考 [1]Garbage Collection In Go : Part II - GC Traces， https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html\n[2]Getting to Go: The Journey of Go’s Garbage Collector, https://blog.golang.org/ismmkeynote\n[3] Golang GC核心要点和度量方法, https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/\n[4] Go memory ballast: How I learnt to stop worrying and love the heap, https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/\n5 附录 5.1 对GODEBUG=gctrace=1信息的解读 gctrace的日志格式为： gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-\u003e#-\u003e# MB, # MB goal, # P 其中各个参数的含义如下: gc # 程序启动以来的GC次数 @#s 程序启动了多久 #% GC过程各个阶段的wall time，分别是sweep termination阶段/mark阶段/mark termination阶段 #+...+# GC消耗的CPU时间，分别是gc assist时间/后台gc时间/idle gc时间 #-\u003e#-\u003e# MB GC开始/结束/最后存活的内存 # MB goal 下次触发GC的堆内存大小 # P 一共使用了几个P ","wordCount":"1630","inLanguage":"en","image":"https://tianyuxue.github.io/pages/images/mountain.jpg","datePublished":"2021-01-02T00:00:00Z","dateModified":"2021-01-02T00:00:00Z","author":{"@type":"Person","name":"jitianyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tianyuxue.github.io/pages/posts/golang-gc/"},"publisher":{"@type":"Organization","name":"ACoder","logo":{"@type":"ImageObject","url":"https://tianyuxue.github.io/pages/images/code.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tianyuxue.github.io/pages accesskey=h title="ACoder (Alt + H)"><img src=https://tianyuxue.github.io/pages/images/code.png alt=logo aria-label=logo height=35>ACoder</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://tianyuxue.github.io/pages/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://tianyuxue.github.io/pages/posts/ title=文章><span>文章</span></a></li><li><a href=https://tianyuxue.github.io/pages/categories/ title=分类><span>分类</span></a></li><li><a href=https://tianyuxue.github.io/pages/tags/ title=标签><span>标签</span></a></li><li><a href=https://tianyuxue.github.io/pages/about/ title=关于我><span><i class='fa fa-heart'></i>关于我</span></a></li><li><a href=https://tianyuxue.github.io/pages/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tianyuxue.github.io/pages>Home</a>&nbsp;»&nbsp;<a href=https://tianyuxue.github.io/pages/posts/>Posts</a></div><h1 class=post-title>关于Golang GC的一些分析</h1><div class=post-meta><span title='2021-01-02 00:00:00 +0000 UTC'>January 2, 2021</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;jitianyu</div></header><figure class=entry-cover><img loading=lazy src=https://tianyuxue.github.io/pages/images/mountain.jpg alt></figure><div class=post-content><blockquote><p>本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法</p><p>本文的讨论基于golang 1.15.4版本</p></blockquote><h2 id=1-golang采用的gc方案>1 Golang采用的GC方案<a hidden class=anchor aria-hidden=true href=#1-golang采用的gc方案>#</a></h2><p>Golang采用了<strong>并发标记-清除</strong>的GC方法，非分代，没有内存整理和移动，这与JVM有很大的不同。对于整个GC过程，源码<code>runtime/mgc.go</code>中给出了较为详细的描述，这里再做一个简要的梳理。整个GC分为以下4个阶段：</p><p>1.<strong>sweep termination</strong></p><p>这个阶段发生在真正GC之前，用来清除上次GC后未被回收的内存，通常这个阶段不会发生，只有在执行了force gc的时候才会触发这个阶段，比如手动调用<code>runtime.GC()</code>函数。</p><p>2.<strong>mark</strong></p><p>mark阶段分为如下几步：</p><ol><li><p>将变量<code>gcphase</code>从<code>_GCoff</code>设置为 <code>_GCmark</code>、开启写屏障功能、启动GC Assists。这个阶段会<strong>STW(Stop The World)</strong>，用户代码会暂停，直到所有P启动写屏障功能为止(如果对P的概念不理解，可以查看另一篇文章了解golang调度的原理)。</p></li><li><p>写屏障启动之后会结束STW状态，用户代码可以正常执行，调度器启动GC Goroutine执行真正的标记任务，GC Assists开始接管GC过程中的内存分配，在这个过程中：</p><ul><li><p>写屏障会将GC过程中修改过的对象标记为灰色，GC过程中新分配的对象则直接标记为黑色，写屏障的作用是为了<strong>维持三色不变性，保证三色标记GC算法正常工作</strong>（三色标记算法过程后文介绍）</p></li><li><p>GC Assist用来<strong>调节GC过程中的内存分配速度</strong>，直观理解，就是GC过程中，用户Goroutine分配的内存越多，其分配速度越慢，甚至会被调度器执行抢占式调度。</p></li></ul></li><li><p>GC Goroutine 会扫描<strong>所有栈</strong>，按照三色标记算法给扫描到的变量标记颜色, 扫描栈的时候，会暂停对应的goroutine, 扫描完成后再恢复gorouine的执行。</p><ul><li><p>三色标记算法的原理如下：</p><ul><li><p>初始所有变量为白色</p></li><li><p>首先将全局变量、被栈引用的堆内对象标记为灰色</p></li><li><p>随机选择一个灰色的对象，将其标记为黑色</p><ul><li>接着扫描该对象的所有可达对象，将可达对象也标记为灰色</li></ul></li><li><p>重复上述过程，直到没有灰色的对象为止</p></li><li><p>这时候白色对象就是可以被回收的。可以看出在整个算法过程中，灰色表示待扫描的对象，黑色代表扫描完毕不可以回收的对象，白色代表可回收的对象，这个不变的特性就<strong>称为三色不变性</strong>。</p></li></ul></li></ul></li></ol><p>3.<strong>mark termination</strong></p><p>在GC Goroutine扫描完所有的栈之后进入mark termination阶段，这个阶段同样会<strong>STW(Stop The World)</strong>, 设置<code>gcphase</code>变量为<code>_GCmarktermination</code>, 然后执行一些资源清理的工作：</p><ul><li>停止GC Goroutine</li><li>禁用GC Assists</li></ul><p>4.<strong>sweep</strong><br>标记结束之后进入sweep阶段，设置<code>gcphace</code>为 _GCoff, 禁用写屏障, 在这之后会Start The World， 启动执行用户代码，这时候意味着并发标记已经结束了，剩下的就是内存回收的工作了。</p><ul><li>从这个阶段开始，新的内存分配请求会<strong>复用</strong>被标记为可回收的内存，这意味着内存的回收是惰性的，不是立刻回收。</li><li>基于cpu使用情况，调度器可能启动额外的goroutine来执行内存回收</li></ul><p>当新分配的内存达到GOGC设定的值后，再次触发GC, 重复上述步骤。</p><ul><li>GOGC用于调整GC频率，GOGC的默认值是100, 意味着下一次GC的触发时机是： 新分配的内存 = 当前GC结束后的剩余内存 × 100%， 例如当前GC结束后剩余4MB内存，当堆内存达到8MB时候，会再次触发GC</li></ul><p><img loading=lazy src=images/Screenshot_2021-01-02-GP_2019_-_An_Insight_Into_Go_Garbage_Collection-pdf.png alt></p><p>GC过程示意图</p><p>整个GC的过程可以见上图。这里再罗嗦一下，Golang采用无内存复制/移动的GC算法，很大的原因是为了兼容谷歌内部的大量C和C++代码，如果GC导致了堆对象的地址变化，那么对于调用C和C++代码而言非常困难。而由于协程的使用，启动写屏障、调度器启动GC Goroutine等操作实际是不涉及内核线程的上下文切换的，因此STW速度很快，这也是并发标记清除算法名称的由来，因此我们看到了Golang这种跟JVM完全不同的内存回收方案。</p><h2 id=2-实践gc调优>2 实践GC调优<a hidden class=anchor aria-hidden=true href=#2-实践gc调优>#</a></h2><p>程序代码的执行必然伴随着内存的分配、修改和释放，GC将程序员从手动内存管理的繁琐工作中解放了出来，很大程度上提高了开发效率。就像任何事情一样，GC也不是免费的，GC的代价就在于消耗了CPU来执行了业务无关代码，从而造成用户代码执行的延迟。从这一点看GC调优与优化内存使用是密切相关的，造成GC过度延迟的根本原因就<strong>在于不恰当的内存分配和使用</strong>。</p><p>GC调优的目的很简单：节约堆内存，降低GC造成的CPU消耗，避免因为GC而导致用户代码执行延迟，尤其是在某些延迟敏感的特定场景。衡量GC损耗的关键指标有三个：GC过程中的cpu使用率，STW时间和STW频率，这三个指标通常是互相关联的，总体上来说，GC的调优就是需要<strong>尽量减少内存分配和释放，尽量复用已经分配的内存</strong>。</p><p>下面通过一个例子来分析GC调优的一些方法，这个例子中首先创建了长度为1000的256位随机字符串数组，然后在每一个web请求中随机生成一个字符串，然后再到字符串数组中查找，这个过程是对查找用户缓存的一个简单模拟，具体代码功能可以参考注释：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;io&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;math/rand&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 用于启动pprof的web接口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;net/http/pprof&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ids 模拟含有1000个用户id的缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ids</span> = make([]<span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 初始化缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRandString</span>(<span style=color:#ae81ff>256</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ids</span> = append(<span style=color:#a6e22e>ids</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/slowgc&#34;</span>, <span style=color:#a6e22e>slowGC</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// slowGC 模拟由于内存分配导致的GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>slowGC</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>currentUser</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRandString</span>(<span style=color:#ae81ff>256</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>id</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ids</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 这里调用了strings.ToLower函数，这个函数会导致字符串的复制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>currentUser</span>), <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>id</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// if strings.Contains(id, currentUser) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;hit&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;not found&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>letters</span> = <span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// getRandString 生成指定位数的字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getRandString</span>(<span style=color:#a6e22e>length</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rnd</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>length</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rnd</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rnd</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>letters</span>[<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(len(<span style=color:#a6e22e>letters</span>))]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> string(<span style=color:#a6e22e>rnd</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=21-分析gc问题的瓶颈>2.1 分析GC问题的瓶颈<a hidden class=anchor aria-hidden=true href=#21-分析gc问题的瓶颈>#</a></h3><p>要观察GC信息主要有以下三种方式</p><ul><li>使用<strong>GODEBUG=gctrace=1</strong>参数启动程序观察GC日志</li><li><strong>go tool pprof</strong>工具可以用来详细分析内存分配，找出程序哪里分配了不合理的内存造成了GC压力</li><li><strong>go tool trace</strong>工具可以列出整个代码执行过程中的详细信息。</li></ul><p>下面我们通过上述的例子，打开<code>GODEBUG=gctrace=1</code>来分析一下GC信息。首先我们执行如下命令启动程序：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go build main.go
</span></span><span style=display:flex><span>GODEBUG<span style=color:#f92672>=</span>gctrace<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ./main
</span></span></code></pre></td></tr></table></div></div><p>接着使用<code>ab</code>工具对接口进行压力测试：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># -c 表示同时发送100个请求</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -n 表示请求总量一共10000个</span>
</span></span><span style=display:flex><span>ab -c <span style=color:#ae81ff>100</span> -n <span style=color:#ae81ff>10000</span> http://localhost:8080/slowgc
</span></span></code></pre></td></tr></table></div></div><p><code>ab</code>工具可以得到类似的结果：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ab -c <span style=color:#ae81ff>100</span> -n <span style=color:#ae81ff>10000</span> http://localhost:8080/slowgc
</span></span><span style=display:flex><span>This is ApacheBench, Version 2.3 &lt;$Revision: <span style=color:#ae81ff>1843412</span> $&gt;
</span></span><span style=display:flex><span>Copyright <span style=color:#ae81ff>1996</span> Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
</span></span><span style=display:flex><span>Licensed to The Apache Software Foundation, http://www.apache.org/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Benchmarking localhost <span style=color:#f92672>(</span>be patient<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>1000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>2000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>3000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>4000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>5000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>6000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>7000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>8000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>9000</span> requests
</span></span><span style=display:flex><span>Completed <span style=color:#ae81ff>10000</span> requests
</span></span><span style=display:flex><span>Finished <span style=color:#ae81ff>10000</span> requests
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Server Software:        
</span></span><span style=display:flex><span>Server Hostname:        localhost
</span></span><span style=display:flex><span>Server Port:            <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Document Path:          /slowgc
</span></span><span style=display:flex><span>Document Length:        <span style=color:#ae81ff>3009</span> bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Concurrency Level:      <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>Time taken <span style=color:#66d9ef>for</span> tests:   23.753 seconds
</span></span><span style=display:flex><span>Complete requests:      <span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>Failed requests:        <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Total transferred:      <span style=color:#ae81ff>31060000</span> bytes
</span></span><span style=display:flex><span>HTML transferred:       <span style=color:#ae81ff>30090000</span> bytes
</span></span><span style=display:flex><span>Requests per second:    421.00 <span style=color:#f92672>[</span><span style=color:#75715e>#/sec] (mean)</span>
</span></span><span style=display:flex><span>Time per request:       237.529 <span style=color:#f92672>[</span>ms<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>mean<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Time per request:       2.375 <span style=color:#f92672>[</span>ms<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>mean, across all concurrent requests<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Transfer rate:          1276.98 <span style=color:#f92672>[</span>Kbytes/sec<span style=color:#f92672>]</span> received
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Connection Times <span style=color:#f92672>(</span>ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              min  mean<span style=color:#f92672>[</span>+/-sd<span style=color:#f92672>]</span> median   max
</span></span><span style=display:flex><span>Connect:        <span style=color:#ae81ff>0</span>    <span style=color:#ae81ff>0</span>   0.3      <span style=color:#ae81ff>0</span>       <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>Processing:     <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>237</span> 136.6    <span style=color:#ae81ff>210</span>    <span style=color:#ae81ff>1217</span>
</span></span><span style=display:flex><span>Waiting:        <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>230</span> 136.2    <span style=color:#ae81ff>204</span>    <span style=color:#ae81ff>1217</span>
</span></span><span style=display:flex><span>Total:          <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>237</span> 136.6    <span style=color:#ae81ff>210</span>    <span style=color:#ae81ff>1217</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Percentage of the requests served within a certain time <span style=color:#f92672>(</span>ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  50%    <span style=color:#ae81ff>210</span>
</span></span><span style=display:flex><span>  66%    <span style=color:#ae81ff>263</span>
</span></span><span style=display:flex><span>  75%    <span style=color:#ae81ff>301</span>
</span></span><span style=display:flex><span>  80%    <span style=color:#ae81ff>331</span>
</span></span><span style=display:flex><span>  90%    <span style=color:#ae81ff>412</span>
</span></span><span style=display:flex><span>  95%    <span style=color:#ae81ff>489</span>
</span></span><span style=display:flex><span>  98%    <span style=color:#ae81ff>598</span>
</span></span><span style=display:flex><span>  99%    <span style=color:#ae81ff>704</span>
</span></span><span style=display:flex><span> 100%   <span style=color:#ae81ff>1217</span> <span style=color:#f92672>(</span>longest request<span style=color:#f92672>)</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看出上面代码的简单逻辑，每秒钟处理的请求数量只有421个，按道理来说简单的字符串查找不应该这么慢，那么问题出在哪里呢，接着看下刚才过程中的gctrace信息：</p><pre tabindex=0><code>...
gc 2619 @25.802s 9%: 0.060+0.61+0.019 ms clock, 0.24+0.73/0.49/0+0.079 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 2620 @25.810s 9%: 0.085+0.68+0.022 ms clock, 0.34+0.80/0.57/0+0.088 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 2621 @25.818s 9%: 0.057+0.42+0.019 ms clock, 0.23+0.63/0.30/0+0.076 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 2622 @25.826s 9%: 0.76+1.7+0.019 ms clock, 3.0+1.9/0.40/0+0.078 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
</code></pre><p>观察压测结束后的gc日志，可以看出10000个请求一共触发了2622次GC，其中GC Groutine一共使用了将近百分之十的CPU，在这样一个简单的业务逻辑下，GC触发的频率明显过高，并且占用的CPU时间也过高（关于GC trace信息的阅读可以参考文末附录），这是不合理的，GC的行为不符合预期的时候，我们首先应该从<strong>内存是否合理</strong>分配来入手分析，接下来我们可以使用go tool pprof工具来查看一下上述代码的内存使用情况：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go tool pprof http://localhost:8080/debug/pprof/allocs
</span></span><span style=display:flex><span>Fetching profile over HTTP from http://localhost:8080/debug/pprof/allocs
</span></span><span style=display:flex><span>Saved profile in /root/pprof/pprof.go-gc-tutorial.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz
</span></span><span style=display:flex><span>File: go-gc-tutorial
</span></span><span style=display:flex><span>Type: alloc_space
</span></span><span style=display:flex><span>Time: Jan 2, <span style=color:#ae81ff>2021</span> at 9:39pm <span style=color:#f92672>(</span>CST<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Entering interactive mode <span style=color:#f92672>(</span>type <span style=color:#e6db74>&#34;help&#34;</span> <span style=color:#66d9ef>for</span> commands, <span style=color:#e6db74>&#34;o&#34;</span> <span style=color:#66d9ef>for</span> options<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> top <span style=color:#ae81ff>6</span> -cum
</span></span><span style=display:flex><span>Showing nodes accounting <span style=color:#66d9ef>for</span> 0, 0% of 7.26GB total
</span></span><span style=display:flex><span>Dropped <span style=color:#ae81ff>58</span> nodes <span style=color:#f92672>(</span>cum &lt;<span style=color:#f92672>=</span> 0.04GB<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Showing top <span style=color:#ae81ff>6</span> nodes out of <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>      flat  flat%   sum%        cum   cum%
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     0%     0%     7.25GB 99.91%  net/http.<span style=color:#f92672>(</span>*conn<span style=color:#f92672>)</span>.serve
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  main.slowGC
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  net/http.<span style=color:#f92672>(</span>*ServeMux<span style=color:#f92672>)</span>.ServeHTTP
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  net/http.HandlerFunc.ServeHTTP
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  net/http.serverHandler.ServeHTTP
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.61%  strings.<span style=color:#f92672>(</span>*Builder<span style=color:#f92672>)</span>.Grow <span style=color:#f92672>(</span>inline<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> list slowGC
</span></span><span style=display:flex><span>Total: 7.26GB
</span></span><span style=display:flex><span>ROUTINE <span style=color:#f92672>========================</span> main.slowGC in /data/codes/go-gc/main1.go
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span>     7.16GB <span style=color:#f92672>(</span>flat, cum<span style=color:#f92672>)</span> 98.68% of Total
</span></span><span style=display:flex><span>         .          .     25:	http.ListenAndServe<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;:8080&#34;</span>, nil<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         .          .     26:<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         .          .     27:
</span></span><span style=display:flex><span>         .          .     28:// slowGC 模拟由于内存分配导致的GC
</span></span><span style=display:flex><span>         .          .     29:func slowGC<span style=color:#f92672>(</span>w http.ResponseWriter, r *http.Request<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .     4.50MB     30:	currentUser :<span style=color:#f92672>=</span> getRandString<span style=color:#f92672>(</span>256<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         .          .     31:	<span style=color:#66d9ef>for</span> _, id :<span style=color:#f92672>=</span> range ids <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .          .     32:		// 这里调用了strings.ToLower函数，这个函数会导致字符串的复制
</span></span><span style=display:flex><span>         .     7.16GB     33:		<span style=color:#66d9ef>if</span> strings.Contains<span style=color:#f92672>(</span>strings.ToLower<span style=color:#f92672>(</span>currentUser<span style=color:#f92672>)</span>, strings.ToLower<span style=color:#f92672>(</span>id<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .          .     34:		// <span style=color:#66d9ef>if</span> strings.Contains<span style=color:#f92672>(</span>id, currentUser<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .   512.02kB     35:			io.WriteString<span style=color:#f92672>(</span>w, <span style=color:#e6db74>&#34;hit&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         .          .     36:		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         .          .     37:	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         .          .     38:	io.WriteString<span style=color:#f92672>(</span>w, <span style=color:#e6db74>&#34;not found&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         .          .     39:<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         .          .     40:
</span></span></code></pre></td></tr></table></div></div><p>首先使用命令</p><pre tabindex=0><code>go tool pprof http://localhost:8080/debug/pprof/allocs
</code></pre><p>进入pprof工具的交互模式，然后输人<code>top 5 -cum</code>查看分配内存最多的5个函数，从输出结果我们可以看出，<code>slowGC</code>函数分配了7GB左右的内存，这有一些奇怪，然后我们可以执行<code>list slowGC</code>命令，可以看出在第33行调用的操作字符串的方法分配内存最多，至此原因大概明白了，golang中string类型是不可变的，每次调用<code>strings.ToLower()</code>方法时候都会申请内存分配一个新的字符串，最后就造成的每次循环中都会申请一块新内存，从而造成GC压力（调用ToLower()方法只是为了举例说明GC问题，并无实际的意义）。我们可以针对这个问题做一下简单的修改，将第33行的ToLower()函数移动到循环之外：</p><pre tabindex=0><code>package main

import (
	&#34;io&#34;
	&#34;math/rand&#34;
	&#34;net/http&#34;

	// 用于启动pprof的web接口
	_ &#34;net/http/pprof&#34;

	&#34;strings&#34;
)

// ids 模拟含有1000个用户id的缓存
var ids = make([]string, 1000)

func main() {
	// 初始化缓存
	for i := 0; i != 1000; i++ {
		s := getRandString(256)
		s = strings.ToLower(s)
		ids = append(ids, s)
	}

	http.HandleFunc(&#34;/slowgc&#34;, slowGC)
	http.ListenAndServe(&#34;:8080&#34;, nil)
}

// slowGC 模拟由于内存分配导致的GC
func slowGC(w http.ResponseWriter, r *http.Request) {
	currentUser := getRandString(256)
        // 将ToLower()的调用移动到循环之外
	currentUser = strings.ToLower(currentUser)
	for _, id := range ids {
		if strings.Contains(id, currentUser) {
			io.WriteString(w, &#34;hit&#34;)
		}
	}
	io.WriteString(w, &#34;not found&#34;)
}

const letters = &#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;

// getRandString 生成指定位数的字符串
func getRandString(length int) string {
	rnd := make([]byte, length)
	for i := range rnd {
		rnd[i] = letters[rand.Intn(len(letters))]
	}
	s := string(rnd)
	return s
}
</code></pre><p>再次执行上述压测命令，可以看到压测结果为：</p><pre tabindex=0><code>ab -c 100 -n 10000 http://localhost:8080/slowgc
This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking localhost (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:        
Server Hostname:        localhost
Server Port:            8080

Document Path:          /slowgc
Document Length:        9 bytes

Concurrency Level:      100
Time taken for tests:   0.880 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      1250000 bytes
HTML transferred:       90000 bytes
Requests per second:    11369.89 [#/sec] (mean)
Time per request:       8.795 [ms] (mean)
Time per request:       0.088 [ms] (mean, across all concurrent requests)
Transfer rate:          1387.93 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    4   0.8      3      10
Processing:     1    5   1.8      5      19
Waiting:        1    4   1.6      4      17
Total:          4    9   1.8      8      23
WARNING: The median and mean for the initial connection time are not within a normal deviation
        These results are probably not that reliable.

Percentage of the requests served within a certain time (ms)
  50%      8
  66%      9
  75%      9
  80%     10
  90%     11
  95%     12
  98%     13
  99%     16
 100%     23 (longest request)
</code></pre><p>从ab命令执行结果来看，处理速度有了极大的改进，每秒处理的请求数量达到了11369，而查看gctrace日志，也可以看到整个过程中只触发了10几次GC：</p><pre tabindex=0><code>...
gc 10 @5.149s 0%: 0.097+0.84+0.007 ms clock, 0.38+1.4/0.001/0+0.028 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 11 @5.208s 0%: 0.037+0.79+0.004 ms clock, 0.14+0.65/0.56/0.25+0.016 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 12 @5.277s 0%: 0.039+0.71+0.003 ms clock, 0.15+0.71/0.55/0+0.014 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 13 @5.346s 0%: 0.023+1.0+0.013 ms clock, 0.094+0.78/0.66/0+0.055 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
</code></pre><p>小结一下，这部分使用了gctrace日志和pprof工具发现了代码中内存分配的缺陷，通过修改代码解决了问题。</p><h3 id=22-调节gogc参数>2.2 调节GOGC参数<a hidden class=anchor aria-hidden=true href=#22-调节gogc参数>#</a></h3><p>上述内存造成的问题也可通过调整GOGC参数来给予临时解决，为什么说是临时解决呢？因为通常修改GOGC参数，虽然减少了GC的触发频率，也可能会带来更长单次GC时间。要从根本上解决GC问题，还是要从代码，或者业务逻辑入手进行优化。下面我们再看下GOGC参数如何影响GC操作。我们用下面的命令设置GOGC的值为500， 意味着堆内存增长5倍，下一次GC才会触发，重新执行2.1中有问题的代码：</p><pre tabindex=0><code>GOGC=500 GODEBUG=gctrace=1 ./main
</code></pre><p>同样执行ab命令进行压测后，得到如下结果：</p><pre tabindex=0><code>ab -c 100 -n 10000 http://localhost:8080/slowgc
This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking localhost (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:        
Server Hostname:        localhost
Server Port:            8080

Document Path:          /slowgc
Document Length:        3009 bytes

Concurrency Level:      100
Time taken for tests:   18.846 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      31060000 bytes
HTML transferred:       30090000 bytes
Requests per second:    530.62 [#/sec] (mean)
Time per request:       188.459 [ms] (mean)
Time per request:       1.885 [ms] (mean, across all concurrent requests)
Transfer rate:          1609.48 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       4
Processing:     6  187 136.9    173    1171
Waiting:        5  184 135.5    170    1171
Total:          6  187 136.9    173    1171

Percentage of the requests served within a certain time (ms)
  50%    173
  66%    226
  75%    256
  80%    283
  90%    362
  95%    437
  98%    545
  99%    641
 100%   1171 (longest request)
</code></pre><p>从<code>ab</code>命令结果可以看出，每秒的请求较之前的400多次变为了500多次，性能略有提升，而gc日志也可以看出，由于修改了GC触发的频率，实际触发的GC次数为394次，比之前的2000多次也是明显减少，整个GC过程的CPU使用率也维持在1%。通过这个例子可以看出，根据实际情况调整GC触发频率对于GC效率是会有较大提升的，但是具体如何设置GOGC的值就是一个开放问题了，需要在不同的场景下不断的测试，最终得到符合当前场景的参数值。</p><pre tabindex=0><code>...
gc 391 @21.304s 1%: 0.063+0.58+0.015 ms clock, 0.25+0.81/0.53/0+0.061 ms cpu, 20-&gt;20-&gt;1 MB, 21 MB goal, 4 P
gc 392 @21.350s 1%: 0.071+0.38+0.017 ms clock, 0.28+0.76/0.32/0+0.069 ms cpu, 20-&gt;20-&gt;1 MB, 21 MB goal, 4 P
gc 393 @21.395s 1%: 0.059+0.36+0.015 ms clock, 0.23+0.57/0.29/0+0.061 ms cpu, 20-&gt;20-&gt;0 MB, 21 MB goal, 4 P
gc 394 @21.439s 1%: 0.066+0.41+0.018 ms clock, 0.26+0.50/0.36/0+0.075 ms cpu, 20-&gt;20-&gt;0 MB, 21 MB goal, 4 P
</code></pre><h3 id=23-gc调优的其他方法>2.3 GC调优的其他方法<a hidden class=anchor aria-hidden=true href=#23-gc调优的其他方法>#</a></h3><p>除了上述的GC调优方法之外，golang编译器提供了逃逸分析的方法，具体而言就是编译器如果可以判断出一个变量创建后只存活在当前栈帧中，那么在当前栈被销毁时候，变量也可以直接销毁，这样就不再需要执行GC去做这部分工作。实际中可以使用<code>go build -gcflags=-m</code>来打开逃逸分析的提示。</p><p>除了逃逸分析之外，另一种常见的控制内存分配的方法是将常用的内存对象池化，<code>sync.Pool</code>就提供了池化对象的支持，除此之外，很多三方库也可以使用，比如<a href=https://github.com/valyala/bytebufferpool>https://github.com/valyala/bytebufferpool</a>。</p><h2 id=3-总结>3 总结<a hidden class=anchor aria-hidden=true href=#3-总结>#</a></h2><p>本文首先介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法。</p><p>本有还有如下的不足：未对逃逸分析和池化对象给出具体的示例。</p><h2 id=4-参考>4 参考<a hidden class=anchor aria-hidden=true href=#4-参考>#</a></h2><p>[1]Garbage Collection In Go : Part II - GC Traces， <a href=https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html>https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html</a></p><p>[2]Getting to Go: The Journey of Go&rsquo;s Garbage Collector, <a href=https://blog.golang.org/ismmkeynote>https://blog.golang.org/ismmkeynote</a></p><p>[3] Golang GC核心要点和度量方法, <a href=https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/>https://w</a><a href=https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/>u</a><a href=https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/>daijun.com/2020/01/go-gc-keypoint-and-monitor/</a></p><p>[4] Go memory ballast: How I learnt to stop worrying and love the heap, <a href=https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/>https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/</a></p><h2 id=5-附录>5 附录<a hidden class=anchor aria-hidden=true href=#5-附录>#</a></h2><h3 id=51-对godebuggctrace1信息的解读>5.1 对GODEBUG=gctrace=1信息的解读<a hidden class=anchor aria-hidden=true href=#51-对godebuggctrace1信息的解读>#</a></h3><pre tabindex=0><code>gctrace的日志格式为：
gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P
其中各个参数的含义如下:
	gc #        程序启动以来的GC次数
	@#s         程序启动了多久
	#%          GC过程各个阶段的wall time，分别是sweep termination阶段/mark阶段/mark termination阶段
	#+...+#     GC消耗的CPU时间，分别是gc assist时间/后台gc时间/idle gc时间
	#-&gt;#-&gt;# MB  GC开始/结束/最后存活的内存
	# MB goal   下次触发GC的堆内存大小
	# P         一共使用了几个P
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://tianyuxue.github.io/pages/tags/gc/>gc</a></li><li><a href=https://tianyuxue.github.io/pages/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://tianyuxue.github.io/pages/posts/kratos-src-mysql/><span class=title>« Prev Page</span><br><span>Kratos 源码分析 - MySQL部分</span></a>
<a class=next href=https://tianyuxue.github.io/pages/posts/golang-scheduler/><span class=title>Next Page »</span><br><span>关于Golang调度器的一些分析</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tianyuxue.github.io/pages>ACoder</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span><div><a href=https://beian.miit.gov.cn/ rel="external nofollow" target=_blank>京ICP备2021000699号</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
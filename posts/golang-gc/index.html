<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>关于Golang GC的一些分析 | ACoder</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
">
<meta name=generator content="Hugo 0.92.0">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<link rel="shortcut icon" href=/images/code.png type=image/x-icon>
<meta property="og:title" content="关于Golang GC的一些分析">
<meta property="og:description" content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
">
<meta property="og:type" content="article">
<meta property="og:url" content="https://tianyuxue.github.io/posts/golang-gc/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-01-02T00:00:00+00:00">
<meta property="article:modified_time" content="2021-01-02T00:00:00+00:00">
<meta itemprop=name content="关于Golang GC的一些分析">
<meta itemprop=description content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
"><meta itemprop=datePublished content="2021-01-02T00:00:00+00:00">
<meta itemprop=dateModified content="2021-01-02T00:00:00+00:00">
<meta itemprop=wordCount content="1481">
<meta itemprop=keywords content="gc,golang,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="关于Golang GC的一些分析">
<meta name=twitter:description content="
本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法
本文的讨论基于golang 1.15.4版本
">
</head>
<body class="ma0 avenir bg-near-white">
<header class="cover bg-top" style=background-image:url(https://tianyuxue.github.io/images/cropped-valais-3562988_1920-2.jpg)>
<div class="pb3-m pb6-l bg-black-10">
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
<img src=/images/cropped-code.png class="w100 mw5-ns" alt=ACoder>
</a>
<div class="flex-l items-center">
<ul class="pl0 mr3">
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/posts/ title="文章 page">
文章
</a>
</li>
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/about/ title="关于我 page">
关于我
</a>
</li>
</ul>
<div class=ananke-socials>
<a href=https://github.com/tianyuxue target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</span></a>
</div>
</div>
</div>
</nav>
<div class="tc-l pv6 ph3 ph4-ns">
<h1 class="f2 f1-l fw2 white-90 mb0 lh-title">关于Golang GC的一些分析</h1>
</div>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">关于Golang GC的一些分析</h1>
<p class=tracked>
By <strong>
jitianyu
</strong>
</p>
<time class="f6 mv4 dib tracked" datetime=2021-01-02T00:00:00Z>January 2, 2021</time>
<span class="f6 mv4 dib tracked"> - 7 minutes read </span>
<span class="f6 mv4 dib tracked"> - 1481 words </span>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><blockquote>
<p>本文介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法</p>
<p>本文的讨论基于golang 1.15.4版本</p>
</blockquote>
<h2 id=1-golang采用的gc方案>1 Golang采用的GC方案</h2>
<p>Golang采用了<strong>并发标记-清除</strong>的GC方法，非分代，没有内存整理和移动，这与JVM有很大的不同。对于整个GC过程，源码<code>runtime/mgc.go</code>中给出了较为详细的描述，这里再做一个简要的梳理。整个GC分为以下4个阶段：</p>
<p>1.<strong>sweep termination</strong></p>
<p>这个阶段发生在真正GC之前，用来清除上次GC后未被回收的内存，通常这个阶段不会发生，只有在执行了force gc的时候才会触发这个阶段，比如手动调用<code>runtime.GC()</code>函数。</p>
<p>2.<strong>mark</strong></p>
<p>mark阶段分为如下几步：</p>
<ol>
<li>
<p>将变量<code>gcphase</code>从<code>_GCoff</code>设置为 <code>_GCmark</code>、开启写屏障功能、启动GC Assists。这个阶段会<strong>STW(Stop The World)</strong>，用户代码会暂停，直到所有P启动写屏障功能为止(如果对P的概念不理解，可以查看另一篇文章了解golang调度的原理)。</p>
</li>
<li>
<p>写屏障启动之后会结束STW状态，用户代码可以正常执行，调度器启动GC Goroutine执行真正的标记任务，GC Assists开始接管GC过程中的内存分配，在这个过程中：</p>
<ul>
<li>
<p>写屏障会将GC过程中修改过的对象标记为灰色，GC过程中新分配的对象则直接标记为黑色，写屏障的作用是为了<strong>维持三色不变性，保证三色标记GC算法正常工作</strong>（三色标记算法过程后文介绍）</p>
</li>
<li>
<p>GC Assist用来<strong>调节GC过程中的内存分配速度</strong>，直观理解，就是GC过程中，用户Goroutine分配的内存越多，其分配速度越慢，甚至会被调度器执行抢占式调度。</p>
</li>
</ul>
</li>
<li>
<p>GC Goroutine 会扫描<strong>所有栈</strong>，按照三色标记算法给扫描到的变量标记颜色, 扫描栈的时候，会暂停对应的goroutine, 扫描完成后再恢复gorouine的执行。</p>
<ul>
<li>
<p>三色标记算法的原理如下：</p>
<ul>
<li>
<p>初始所有变量为白色</p>
</li>
<li>
<p>首先将全局变量、被栈引用的堆内对象标记为灰色</p>
</li>
<li>
<p>随机选择一个灰色的对象，将其标记为黑色</p>
<ul>
<li>接着扫描该对象的所有可达对象，将可达对象也标记为灰色</li>
</ul>
</li>
<li>
<p>重复上述过程，直到没有灰色的对象为止</p>
</li>
<li>
<p>这时候白色对象就是可以被回收的。可以看出在整个算法过程中，灰色表示待扫描的对象，黑色代表扫描完毕不可以回收的对象，白色代表可回收的对象，这个不变的特性就<strong>称为三色不变性</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>3.<strong>mark termination</strong></p>
<p>在GC Goroutine扫描完所有的栈之后进入mark termination阶段，这个阶段同样会<strong>STW(Stop The World)</strong>, 设置<code>gcphase</code>变量为<code>_GCmarktermination</code>, 然后执行一些资源清理的工作：</p>
<ul>
<li>停止GC Goroutine</li>
<li>禁用GC Assists</li>
</ul>
<p>4.<strong>sweep</strong><br>
标记结束之后进入sweep阶段，设置<code>gcphace</code>为 _GCoff, 禁用写屏障, 在这之后会Start The World， 启动执行用户代码，这时候意味着并发标记已经结束了，剩下的就是内存回收的工作了。</p>
<ul>
<li>从这个阶段开始，新的内存分配请求会<strong>复用</strong>被标记为可回收的内存，这意味着内存的回收是惰性的，不是立刻回收。</li>
<li>基于cpu使用情况，调度器可能启动额外的goroutine来执行内存回收</li>
</ul>
<p>当新分配的内存达到GOGC设定的值后，再次触发GC, 重复上述步骤。</p>
<ul>
<li>GOGC用于调整GC频率，GOGC的默认值是100, 意味着下一次GC的触发时机是： 新分配的内存 = 当前GC结束后的剩余内存 × 100%， 例如当前GC结束后剩余4MB内存，当堆内存达到8MB时候，会再次触发GC</li>
</ul>
<p><img src=images/Screenshot_2021-01-02-GP_2019_-_An_Insight_Into_Go_Garbage_Collection-pdf.png alt></p>
<p>GC过程示意图</p>
<p>整个GC的过程可以见上图。这里再罗嗦一下，Golang采用无内存复制/移动的GC算法，很大的原因是为了兼容谷歌内部的大量C和C++代码，如果GC导致了堆对象的地址变化，那么对于调用C和C++代码而言非常困难。而由于协程的使用，启动写屏障、调度器启动GC Goroutine等操作实际是不涉及内核线程的上下文切换的，因此STW速度很快，这也是并发标记清除算法名称的由来，因此我们看到了Golang这种跟JVM完全不同的内存回收方案。</p>
<h2 id=2-实践gc调优>2 实践GC调优</h2>
<p>程序代码的执行必然伴随着内存的分配、修改和释放，GC将程序员从手动内存管理的繁琐工作中解放了出来，很大程度上提高了开发效率。就像任何事情一样，GC也不是免费的，GC的代价就在于消耗了CPU来执行了业务无关代码，从而造成用户代码执行的延迟。从这一点看GC调优与优化内存使用是密切相关的，造成GC过度延迟的根本原因就<strong>在于不恰当的内存分配和使用</strong>。</p>
<p>GC调优的目的很简单：节约堆内存，降低GC造成的CPU消耗，避免因为GC而导致用户代码执行延迟，尤其是在某些延迟敏感的特定场景。衡量GC损耗的关键指标有三个：GC过程中的cpu使用率，STW时间和STW频率，这三个指标通常是互相关联的，总体上来说，GC的调优就是需要<strong>尽量减少内存分配和释放，尽量复用已经分配的内存</strong>。</p>
<p>下面通过一个例子来分析GC调优的一些方法，这个例子中首先创建了长度为1000的256位随机字符串数组，然后在每一个web请求中随机生成一个字符串，然后再到字符串数组中查找，这个过程是对查找用户缓存的一个简单模拟，具体代码功能可以参考注释：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;io&#34;</span>
	<span style=color:#e6db74>&#34;math/rand&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>

	<span style=color:#75715e>// 用于启动pprof的web接口
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;net/http/pprof&#34;</span>

	<span style=color:#e6db74>&#34;strings&#34;</span>
)

<span style=color:#75715e>// ids 模拟含有1000个用户id的缓存
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ids</span> = make([]<span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>1000</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#75715e>// 初始化缓存
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRandString</span>(<span style=color:#ae81ff>256</span>)
		<span style=color:#a6e22e>ids</span> = append(<span style=color:#a6e22e>ids</span>, <span style=color:#a6e22e>s</span>)
	}

	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/slowgc&#34;</span>, <span style=color:#a6e22e>slowGC</span>)
	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
}

<span style=color:#75715e>// slowGC 模拟由于内存分配导致的GC
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>slowGC</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>currentUser</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRandString</span>(<span style=color:#ae81ff>256</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>id</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ids</span> {
		<span style=color:#75715e>// 这里调用了strings.ToLower函数，这个函数会导致字符串的复制
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>currentUser</span>), <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>id</span>)) {
		<span style=color:#75715e>// if strings.Contains(id, currentUser) {
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;hit&#34;</span>)
		}
	}
	<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;not found&#34;</span>)
}

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>letters</span> = <span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>

<span style=color:#75715e>// getRandString 生成指定位数的字符串
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getRandString</span>(<span style=color:#a6e22e>length</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#a6e22e>rnd</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>length</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rnd</span> {
		<span style=color:#a6e22e>rnd</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>letters</span>[<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(len(<span style=color:#a6e22e>letters</span>))]
	}
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> string(<span style=color:#a6e22e>rnd</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
}
</code></pre></div><h3 id=21-分析gc问题的瓶颈>2.1 分析GC问题的瓶颈</h3>
<p>要观察GC信息主要有以下三种方式</p>
<ul>
<li>使用<strong>GODEBUG=gctrace=1</strong>参数启动程序观察GC日志</li>
<li><strong>go tool pprof</strong>工具可以用来详细分析内存分配，找出程序哪里分配了不合理的内存造成了GC压力</li>
<li><strong>go tool trace</strong>工具可以列出整个代码执行过程中的详细信息。</li>
</ul>
<p>下面我们通过上述的例子，打开<code>GODEBUG=gctrace=1</code>来分析一下GC信息。首先我们执行如下命令启动程序：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go build main.go
GODEBUG<span style=color:#f92672>=</span>gctrace<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ./main
</code></pre></div><p>接着使用<code>ab</code>工具对接口进行压力测试：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># -c 表示同时发送100个请求</span>
<span style=color:#75715e># -n 表示请求总量一共10000个</span>
ab -c <span style=color:#ae81ff>100</span> -n <span style=color:#ae81ff>10000</span> http://localhost:8080/slowgc
</code></pre></div><p><code>ab</code>工具可以得到类似的结果：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ab -c <span style=color:#ae81ff>100</span> -n <span style=color:#ae81ff>10000</span> http://localhost:8080/slowgc
This is ApacheBench, Version 2.3 &lt;$Revision: <span style=color:#ae81ff>1843412</span> $&gt;
Copyright <span style=color:#ae81ff>1996</span> Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking localhost <span style=color:#f92672>(</span>be patient<span style=color:#f92672>)</span>
Completed <span style=color:#ae81ff>1000</span> requests
Completed <span style=color:#ae81ff>2000</span> requests
Completed <span style=color:#ae81ff>3000</span> requests
Completed <span style=color:#ae81ff>4000</span> requests
Completed <span style=color:#ae81ff>5000</span> requests
Completed <span style=color:#ae81ff>6000</span> requests
Completed <span style=color:#ae81ff>7000</span> requests
Completed <span style=color:#ae81ff>8000</span> requests
Completed <span style=color:#ae81ff>9000</span> requests
Completed <span style=color:#ae81ff>10000</span> requests
Finished <span style=color:#ae81ff>10000</span> requests


Server Software:        
Server Hostname:        localhost
Server Port:            <span style=color:#ae81ff>8080</span>

Document Path:          /slowgc
Document Length:        <span style=color:#ae81ff>3009</span> bytes

Concurrency Level:      <span style=color:#ae81ff>100</span>
Time taken <span style=color:#66d9ef>for</span> tests:   23.753 seconds
Complete requests:      <span style=color:#ae81ff>10000</span>
Failed requests:        <span style=color:#ae81ff>0</span>
Total transferred:      <span style=color:#ae81ff>31060000</span> bytes
HTML transferred:       <span style=color:#ae81ff>30090000</span> bytes
Requests per second:    421.00 <span style=color:#f92672>[</span><span style=color:#75715e>#/sec] (mean)</span>
Time per request:       237.529 <span style=color:#f92672>[</span>ms<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>mean<span style=color:#f92672>)</span>
Time per request:       2.375 <span style=color:#f92672>[</span>ms<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>mean, across all concurrent requests<span style=color:#f92672>)</span>
Transfer rate:          1276.98 <span style=color:#f92672>[</span>Kbytes/sec<span style=color:#f92672>]</span> received

Connection Times <span style=color:#f92672>(</span>ms<span style=color:#f92672>)</span>
              min  mean<span style=color:#f92672>[</span>+/-sd<span style=color:#f92672>]</span> median   max
Connect:        <span style=color:#ae81ff>0</span>    <span style=color:#ae81ff>0</span>   0.3      <span style=color:#ae81ff>0</span>       <span style=color:#ae81ff>5</span>
Processing:     <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>237</span> 136.6    <span style=color:#ae81ff>210</span>    <span style=color:#ae81ff>1217</span>
Waiting:        <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>230</span> 136.2    <span style=color:#ae81ff>204</span>    <span style=color:#ae81ff>1217</span>
Total:          <span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>237</span> 136.6    <span style=color:#ae81ff>210</span>    <span style=color:#ae81ff>1217</span>

Percentage of the requests served within a certain time <span style=color:#f92672>(</span>ms<span style=color:#f92672>)</span>
  50%    <span style=color:#ae81ff>210</span>
  66%    <span style=color:#ae81ff>263</span>
  75%    <span style=color:#ae81ff>301</span>
  80%    <span style=color:#ae81ff>331</span>
  90%    <span style=color:#ae81ff>412</span>
  95%    <span style=color:#ae81ff>489</span>
  98%    <span style=color:#ae81ff>598</span>
  99%    <span style=color:#ae81ff>704</span>
 100%   <span style=color:#ae81ff>1217</span> <span style=color:#f92672>(</span>longest request<span style=color:#f92672>)</span>
</code></pre></div><p>可以看出上面代码的简单逻辑，每秒钟处理的请求数量只有421个，按道理来说简单的字符串查找不应该这么慢，那么问题出在哪里呢，接着看下刚才过程中的gctrace信息：</p>
<pre tabindex=0><code>...
gc 2619 @25.802s 9%: 0.060+0.61+0.019 ms clock, 0.24+0.73/0.49/0+0.079 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 2620 @25.810s 9%: 0.085+0.68+0.022 ms clock, 0.34+0.80/0.57/0+0.088 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 2621 @25.818s 9%: 0.057+0.42+0.019 ms clock, 0.23+0.63/0.30/0+0.076 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 2622 @25.826s 9%: 0.76+1.7+0.019 ms clock, 3.0+1.9/0.40/0+0.078 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
</code></pre><p>观察压测结束后的gc日志，可以看出10000个请求一共触发了2622次GC，其中GC Groutine一共使用了将近百分之十的CPU，在这样一个简单的业务逻辑下，GC触发的频率明显过高，并且占用的CPU时间也过高（关于GC trace信息的阅读可以参考文末附录），这是不合理的，GC的行为不符合预期的时候，我们首先应该从<strong>内存是否合理</strong>分配来入手分析，接下来我们可以使用go tool pprof工具来查看一下上述代码的内存使用情况：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go tool pprof http://localhost:8080/debug/pprof/allocs
Fetching profile over HTTP from http://localhost:8080/debug/pprof/allocs
Saved profile in /root/pprof/pprof.go-gc-tutorial.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz
File: go-gc-tutorial
Type: alloc_space
Time: Jan 2, <span style=color:#ae81ff>2021</span> at 9:39pm <span style=color:#f92672>(</span>CST<span style=color:#f92672>)</span>
Entering interactive mode <span style=color:#f92672>(</span>type <span style=color:#e6db74>&#34;help&#34;</span> <span style=color:#66d9ef>for</span> commands, <span style=color:#e6db74>&#34;o&#34;</span> <span style=color:#66d9ef>for</span> options<span style=color:#f92672>)</span>
<span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> top <span style=color:#ae81ff>6</span> -cum
Showing nodes accounting <span style=color:#66d9ef>for</span> 0, 0% of 7.26GB total
Dropped <span style=color:#ae81ff>58</span> nodes <span style=color:#f92672>(</span>cum &lt;<span style=color:#f92672>=</span> 0.04GB<span style=color:#f92672>)</span>
Showing top <span style=color:#ae81ff>6</span> nodes out of <span style=color:#ae81ff>8</span>
      flat  flat%   sum%        cum   cum%
         <span style=color:#ae81ff>0</span>     0%     0%     7.25GB 99.91%  net/http.<span style=color:#f92672>(</span>*conn<span style=color:#f92672>)</span>.serve
         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  main.slowGC
         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  net/http.<span style=color:#f92672>(</span>*ServeMux<span style=color:#f92672>)</span>.ServeHTTP
         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  net/http.HandlerFunc.ServeHTTP
         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.68%  net/http.serverHandler.ServeHTTP
         <span style=color:#ae81ff>0</span>     0%     0%     7.16GB 98.61%  strings.<span style=color:#f92672>(</span>*Builder<span style=color:#f92672>)</span>.Grow <span style=color:#f92672>(</span>inline<span style=color:#f92672>)</span>
<span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> 
<span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> list slowGC
Total: 7.26GB
ROUTINE <span style=color:#f92672>========================</span> main.slowGC in /data/codes/go-gc/main1.go
         <span style=color:#ae81ff>0</span>     7.16GB <span style=color:#f92672>(</span>flat, cum<span style=color:#f92672>)</span> 98.68% of Total
         .          .     25:	http.ListenAndServe<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;:8080&#34;</span>, nil<span style=color:#f92672>)</span>
         .          .     26:<span style=color:#f92672>}</span>
         .          .     27:
         .          .     28:// slowGC 模拟由于内存分配导致的GC
         .          .     29:func slowGC<span style=color:#f92672>(</span>w http.ResponseWriter, r *http.Request<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
         .     4.50MB     30:	currentUser :<span style=color:#f92672>=</span> getRandString<span style=color:#f92672>(</span>256<span style=color:#f92672>)</span>
         .          .     31:	<span style=color:#66d9ef>for</span> _, id :<span style=color:#f92672>=</span> range ids <span style=color:#f92672>{</span>
         .          .     32:		// 这里调用了strings.ToLower函数，这个函数会导致字符串的复制
         .     7.16GB     33:		<span style=color:#66d9ef>if</span> strings.Contains<span style=color:#f92672>(</span>strings.ToLower<span style=color:#f92672>(</span>currentUser<span style=color:#f92672>)</span>, strings.ToLower<span style=color:#f92672>(</span>id<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
         .          .     34:		// <span style=color:#66d9ef>if</span> strings.Contains<span style=color:#f92672>(</span>id, currentUser<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
         .   512.02kB     35:			io.WriteString<span style=color:#f92672>(</span>w, <span style=color:#e6db74>&#34;hit&#34;</span><span style=color:#f92672>)</span>
         .          .     36:		<span style=color:#f92672>}</span>
         .          .     37:	<span style=color:#f92672>}</span>
         .          .     38:	io.WriteString<span style=color:#f92672>(</span>w, <span style=color:#e6db74>&#34;not found&#34;</span><span style=color:#f92672>)</span>
         .          .     39:<span style=color:#f92672>}</span>
         .          .     40:
</code></pre></div><p>首先使用命令</p>
<pre tabindex=0><code>go tool pprof http://localhost:8080/debug/pprof/allocs
</code></pre><p>进入pprof工具的交互模式，然后输人<code>top 5 -cum</code>查看分配内存最多的5个函数，从输出结果我们可以看出，<code>slowGC</code>函数分配了7GB左右的内存，这有一些奇怪，然后我们可以执行<code>list slowGC</code>命令，可以看出在第33行调用的操作字符串的方法分配内存最多，至此原因大概明白了，golang中string类型是不可变的，每次调用<code>strings.ToLower()</code>方法时候都会申请内存分配一个新的字符串，最后就造成的每次循环中都会申请一块新内存，从而造成GC压力（调用ToLower()方法只是为了举例说明GC问题，并无实际的意义）。我们可以针对这个问题做一下简单的修改，将第33行的ToLower()函数移动到循环之外：</p>
<pre tabindex=0><code>package main

import (
	&quot;io&quot;
	&quot;math/rand&quot;
	&quot;net/http&quot;

	// 用于启动pprof的web接口
	_ &quot;net/http/pprof&quot;

	&quot;strings&quot;
)

// ids 模拟含有1000个用户id的缓存
var ids = make([]string, 1000)

func main() {
	// 初始化缓存
	for i := 0; i != 1000; i++ {
		s := getRandString(256)
		s = strings.ToLower(s)
		ids = append(ids, s)
	}

	http.HandleFunc(&quot;/slowgc&quot;, slowGC)
	http.ListenAndServe(&quot;:8080&quot;, nil)
}

// slowGC 模拟由于内存分配导致的GC
func slowGC(w http.ResponseWriter, r *http.Request) {
	currentUser := getRandString(256)
        // 将ToLower()的调用移动到循环之外
	currentUser = strings.ToLower(currentUser)
	for _, id := range ids {
		if strings.Contains(id, currentUser) {
			io.WriteString(w, &quot;hit&quot;)
		}
	}
	io.WriteString(w, &quot;not found&quot;)
}

const letters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;

// getRandString 生成指定位数的字符串
func getRandString(length int) string {
	rnd := make([]byte, length)
	for i := range rnd {
		rnd[i] = letters[rand.Intn(len(letters))]
	}
	s := string(rnd)
	return s
}
</code></pre><p>再次执行上述压测命令，可以看到压测结果为：</p>
<pre tabindex=0><code>ab -c 100 -n 10000 http://localhost:8080/slowgc
This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking localhost (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:        
Server Hostname:        localhost
Server Port:            8080

Document Path:          /slowgc
Document Length:        9 bytes

Concurrency Level:      100
Time taken for tests:   0.880 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      1250000 bytes
HTML transferred:       90000 bytes
Requests per second:    11369.89 [#/sec] (mean)
Time per request:       8.795 [ms] (mean)
Time per request:       0.088 [ms] (mean, across all concurrent requests)
Transfer rate:          1387.93 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    4   0.8      3      10
Processing:     1    5   1.8      5      19
Waiting:        1    4   1.6      4      17
Total:          4    9   1.8      8      23
WARNING: The median and mean for the initial connection time are not within a normal deviation
        These results are probably not that reliable.

Percentage of the requests served within a certain time (ms)
  50%      8
  66%      9
  75%      9
  80%     10
  90%     11
  95%     12
  98%     13
  99%     16
 100%     23 (longest request)
</code></pre><p>从ab命令执行结果来看，处理速度有了极大的改进，每秒处理的请求数量达到了11369，而查看gctrace日志，也可以看到整个过程中只触发了10几次GC：</p>
<pre tabindex=0><code>...
gc 10 @5.149s 0%: 0.097+0.84+0.007 ms clock, 0.38+1.4/0.001/0+0.028 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 11 @5.208s 0%: 0.037+0.79+0.004 ms clock, 0.14+0.65/0.56/0.25+0.016 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 12 @5.277s 0%: 0.039+0.71+0.003 ms clock, 0.15+0.71/0.55/0+0.014 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 13 @5.346s 0%: 0.023+1.0+0.013 ms clock, 0.094+0.78/0.66/0+0.055 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
</code></pre><p>小结一下，这部分使用了gctrace日志和pprof工具发现了代码中内存分配的缺陷，通过修改代码解决了问题。</p>
<h3 id=22-调节gogc参数>2.2 调节GOGC参数</h3>
<p>上述内存造成的问题也可通过调整GOGC参数来给予临时解决，为什么说是临时解决呢？因为通常修改GOGC参数，虽然减少了GC的触发频率，也可能会带来更长单次GC时间。要从根本上解决GC问题，还是要从代码，或者业务逻辑入手进行优化。下面我们再看下GOGC参数如何影响GC操作。我们用下面的命令设置GOGC的值为500， 意味着堆内存增长5倍，下一次GC才会触发，重新执行2.1中有问题的代码：</p>
<pre tabindex=0><code>GOGC=500 GODEBUG=gctrace=1 ./main
</code></pre><p>同样执行ab命令进行压测后，得到如下结果：</p>
<pre tabindex=0><code>ab -c 100 -n 10000 http://localhost:8080/slowgc
This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking localhost (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:        
Server Hostname:        localhost
Server Port:            8080

Document Path:          /slowgc
Document Length:        3009 bytes

Concurrency Level:      100
Time taken for tests:   18.846 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      31060000 bytes
HTML transferred:       30090000 bytes
Requests per second:    530.62 [#/sec] (mean)
Time per request:       188.459 [ms] (mean)
Time per request:       1.885 [ms] (mean, across all concurrent requests)
Transfer rate:          1609.48 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       4
Processing:     6  187 136.9    173    1171
Waiting:        5  184 135.5    170    1171
Total:          6  187 136.9    173    1171

Percentage of the requests served within a certain time (ms)
  50%    173
  66%    226
  75%    256
  80%    283
  90%    362
  95%    437
  98%    545
  99%    641
 100%   1171 (longest request)
</code></pre><p>从<code>ab</code>命令结果可以看出，每秒的请求较之前的400多次变为了500多次，性能略有提升，而gc日志也可以看出，由于修改了GC触发的频率，实际触发的GC次数为394次，比之前的2000多次也是明显减少，整个GC过程的CPU使用率也维持在1%。通过这个例子可以看出，根据实际情况调整GC触发频率对于GC效率是会有较大提升的，但是具体如何设置GOGC的值就是一个开放问题了，需要在不同的场景下不断的测试，最终得到符合当前场景的参数值。</p>
<pre tabindex=0><code>...
gc 391 @21.304s 1%: 0.063+0.58+0.015 ms clock, 0.25+0.81/0.53/0+0.061 ms cpu, 20-&gt;20-&gt;1 MB, 21 MB goal, 4 P
gc 392 @21.350s 1%: 0.071+0.38+0.017 ms clock, 0.28+0.76/0.32/0+0.069 ms cpu, 20-&gt;20-&gt;1 MB, 21 MB goal, 4 P
gc 393 @21.395s 1%: 0.059+0.36+0.015 ms clock, 0.23+0.57/0.29/0+0.061 ms cpu, 20-&gt;20-&gt;0 MB, 21 MB goal, 4 P
gc 394 @21.439s 1%: 0.066+0.41+0.018 ms clock, 0.26+0.50/0.36/0+0.075 ms cpu, 20-&gt;20-&gt;0 MB, 21 MB goal, 4 P
</code></pre><h3 id=23-gc调优的其他方法>2.3 GC调优的其他方法</h3>
<p>除了上述的GC调优方法之外，golang编译器提供了逃逸分析的方法，具体而言就是编译器如果可以判断出一个变量创建后只存活在当前栈帧中，那么在当前栈被销毁时候，变量也可以直接销毁，这样就不再需要执行GC去做这部分工作。实际中可以使用<code>go build -gcflags=-m</code>来打开逃逸分析的提示。</p>
<p>除了逃逸分析之外，另一种常见的控制内存分配的方法是将常用的内存对象池化，<code>sync.Pool</code>就提供了池化对象的支持，除此之外，很多三方库也可以使用，比如<a href=https://github.com/valyala/bytebufferpool>https://github.com/valyala/bytebufferpool</a>。</p>
<h2 id=3-总结>3 总结</h2>
<p>本文首先介绍了Golang中GC的执行过程，然后用一个例子，结合golang提供的GC日志和pprof工具，介绍GC调优的基本方法。</p>
<p>本有还有如下的不足：未对逃逸分析和池化对象给出具体的示例。</p>
<h2 id=4-参考>4 参考</h2>
<p>[1]Garbage Collection In Go : Part II - GC Traces， <a href=https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html>https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html</a></p>
<p>[2]Getting to Go: The Journey of Go&rsquo;s Garbage Collector, <a href=https://blog.golang.org/ismmkeynote>https://blog.golang.org/ismmkeynote</a></p>
<p>[3] Golang GC核心要点和度量方法, <a href=https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/>https://w</a><a href=https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/>u</a><a href=https://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/>daijun.com/2020/01/go-gc-keypoint-and-monitor/</a></p>
<p>[4] Go memory ballast: How I learnt to stop worrying and love the heap, <a href=https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/>https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/</a></p>
<h2 id=5-附录>5 附录</h2>
<h3 id=51-对godebuggctrace1信息的解读>5.1 对GODEBUG=gctrace=1信息的解读</h3>
<pre tabindex=0><code>gctrace的日志格式为：
gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P
其中各个参数的含义如下:
	gc #        程序启动以来的GC次数
	@#s         程序启动了多久
	#%          GC过程各个阶段的wall time，分别是sweep termination阶段/mark阶段/mark termination阶段
	#+...+#     GC消耗的CPU时间，分别是gc assist时间/后台gc时间/idle gc时间
	#-&gt;#-&gt;# MB  GC开始/结束/最后存活的内存
	# MB goal   下次触发GC的堆内存大小
	# P         一共使用了几个P
</code></pre><div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
<div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
<p class="f5 b mb3">Related</p>
<ul class="pa0 list">
<li class=mb2>
<a href=/posts/golang-scheduler/>关于Golang调度器的一些分析</a>
</li>
</ul>
</div>
<div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
<p class="f5 b mb3">Tags</p>
<ul class=pa0>
<li class=list>
<a href=/tags/gc class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">gc</a>
</li>
<li class=list>
<a href=/tags/golang class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">golang</a>
</li>
</ul>
</div>
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://tianyuxue.github.io/>
&copy; ACoder 2022
</a>
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://beian.miit.gov.cn/ rel="external nofollow" target=_blank>京ICP备2021000699号</a>
</div>
</footer>
</body>
</html>